"""Data models for verification system."""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum


class VerificationStatus(str, Enum):
    """Status of a verification result."""

    VERIFIED = "verified"  # >72% confidence, auto-accepted
    FLAGGED = "flagged"  # 45-72% confidence, needs review
    REJECTED = "rejected"  # <45% confidence, should trigger additional search
    SKIPPED = "skipped"  # Verification skipped (disabled or error)
    PENDING = "pending"  # Not yet verified


class VerificationMethod(str, Enum):
    """Method used for verification."""

    COVE = "cove"  # Chain-of-Verification
    CRITIC = "critic"  # CRITIC iterative verification
    KG_MATCH = "kg_match"  # Knowledge graph corroboration
    COVE_CRITIC = "cove_critic"  # Combined CoVe + CRITIC
    STREAMING = "streaming"  # Lightweight streaming verification
    BATCH = "batch"  # Comprehensive batch verification


@dataclass
class VerificationQuestion:
    """A verification question generated by CoVe."""

    question: str
    aspect: str  # What aspect of the finding this verifies (factual, temporal, source, etc.)
    independent_answer: str | None = None
    supports_original: bool | None = None
    confidence: float = 0.0


@dataclass
class ContradictionDetail:
    """Details about a detected contradiction."""

    finding_id: str
    conflicting_finding_id: str
    description: str
    severity: str = "medium"  # low, medium, high
    resolution_suggestion: str | None = None


@dataclass
class VerificationResult:
    """Result of verifying a finding."""

    finding_id: str
    original_confidence: float
    verified_confidence: float
    verification_status: VerificationStatus
    verification_method: VerificationMethod

    # CoVe results (None = not computed, 0.0 = computed as zero)
    questions_asked: list[VerificationQuestion] = field(default_factory=list)
    consistency_score: float | None = None

    # KG results (None = not computed)
    kg_support_score: float | None = None
    kg_entity_matches: int | None = None
    kg_supporting_relations: int | None = None

    # CRITIC results (None = not run)
    critic_iterations: int | None = None
    corrections_made: list[str] = field(default_factory=list)
    external_verification_used: bool = False

    # HHEM source-grounding score (-1.0 = not scored)
    hhem_grounding_score: float = -1.0

    # Contradiction detection
    contradictions: list[ContradictionDetail] = field(default_factory=list)

    # Timing
    verification_time_ms: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)

    # Error handling
    error: str | None = None

    def to_dict(self) -> dict:
        """Convert to dictionary for storage/serialization."""
        return {
            "finding_id": self.finding_id,
            "original_confidence": self.original_confidence,
            "verified_confidence": self.verified_confidence,
            "verification_status": self.verification_status.value,
            "verification_method": self.verification_method.value,
            "questions_asked": [
                {
                    "question": q.question,
                    "aspect": q.aspect,
                    "independent_answer": q.independent_answer,
                    "supports_original": q.supports_original,
                    "confidence": q.confidence,
                }
                for q in self.questions_asked
            ],
            "consistency_score": self.consistency_score,
            "kg_support_score": self.kg_support_score,
            "kg_entity_matches": self.kg_entity_matches,
            "kg_supporting_relations": self.kg_supporting_relations,
            "critic_iterations": self.critic_iterations,
            "corrections_made": self.corrections_made,
            "external_verification_used": self.external_verification_used,
            "hhem_grounding_score": self.hhem_grounding_score,
            "contradictions": [
                {
                    "finding_id": c.finding_id,
                    "conflicting_finding_id": c.conflicting_finding_id,
                    "description": c.description,
                    "severity": c.severity,
                    "resolution_suggestion": c.resolution_suggestion,
                }
                for c in self.contradictions
            ],
            "verification_time_ms": self.verification_time_ms,
            "timestamp": self.timestamp.isoformat(),
            "error": self.error,
        }


@dataclass
class BatchVerificationResult:
    """Result of batch verification of multiple findings."""

    session_id: str
    total_findings: int
    verified_count: int
    flagged_count: int
    rejected_count: int
    skipped_count: int

    results: list[VerificationResult] = field(default_factory=list)
    contradictions_found: list[ContradictionDetail] = field(default_factory=list)

    total_time_ms: float = 0.0
    avg_time_per_finding_ms: float = 0.0

    def get_by_status(self, status: VerificationStatus) -> list[VerificationResult]:
        """Get all results with a specific status."""
        return [r for r in self.results if r.verification_status == status]

    def get_high_confidence_findings(self) -> list[VerificationResult]:
        """Get findings with verified status (>85% confidence)."""
        return self.get_by_status(VerificationStatus.VERIFIED)

    def to_dict(self) -> dict:
        """Convert to dictionary for storage/serialization."""
        return {
            "session_id": self.session_id,
            "total_findings": self.total_findings,
            "verified_count": self.verified_count,
            "flagged_count": self.flagged_count,
            "rejected_count": self.rejected_count,
            "skipped_count": self.skipped_count,
            "results": [r.to_dict() for r in self.results],
            "contradictions_found": [
                {
                    "finding_id": c.finding_id,
                    "conflicting_finding_id": c.conflicting_finding_id,
                    "description": c.description,
                    "severity": c.severity,
                }
                for c in self.contradictions_found
            ],
            "total_time_ms": self.total_time_ms,
            "avg_time_per_finding_ms": self.avg_time_per_finding_ms,
        }


@dataclass
class VerificationConfig:
    """Configuration for the verification system."""

    # Confidence thresholds
    auto_accept_threshold: float = 0.72  # >72% = VERIFIED
    flag_threshold: float = 0.45  # 45-72% = FLAGGED, <45% = REJECTED

    # Feature toggles
    enable_streaming_verification: bool = True
    enable_batch_verification: bool = True
    enable_critic: bool = True
    enable_kg_verification: bool = True
    enable_hhem: bool = True

    # HHEM thresholds
    hhem_reject_threshold: float = 0.25  # Below this = reject immediately
    hhem_boost_threshold: float = 0.7  # Above this = boost confidence

    # CoVe settings
    max_cove_questions_streaming: int = 2  # Quick verification
    max_cove_questions_batch: int = 5  # Thorough verification

    # CRITIC settings
    max_critic_iterations: int = 3
    critic_confidence_threshold: float = 0.8  # Use CRITIC if below this

    # Model selection
    streaming_model: str = "haiku"  # Fast for streaming
    batch_model: str = "sonnet"  # Thorough for batch

    # KG settings
    kg_support_boost: float = 0.1  # Boost confidence by up to 10% for KG match
    kg_contradiction_penalty: float = 0.08  # Reduce confidence by 8% for KG contradiction

    # Performance settings
    streaming_timeout_ms: int = 500  # Target <500ms for streaming
    batch_timeout_ms: int = 2000  # Target ~2s for batch
    parallel_batch_size: int = 5  # Process 5 findings in parallel
